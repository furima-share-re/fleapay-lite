# 接続方式のパフォーマンス比較

**更新日**: 2026-01-02

---

## 📊 パフォーマンス比較

### Direct connection vs Transaction pooler vs Session pooler

| 項目 | Direct connection | Transaction pooler | Session pooler |
|------|------------------|-------------------|----------------|
| **レスポンス時間** | 最短（直接接続） | やや長い（+1-5ms程度） | やや長い（+1-5ms程度） |
| **接続オーバーヘッド** | 低い | 中程度（プーリング） | 中程度（プーリング） |
| **同時接続数** | 制限あり | 高い（プーリング） | 高い（プーリング） |
| **スケーラビリティ** | 低い | 高い | 高い |
| **IPv4互換** | ❌ なし | ✅ あり | ✅ あり |
| **用途** | 永続接続 | ステートレスアプリ | Direct Connectionの代替 |

---

## ⏱️ レスポンス時間の違い

### 一般的な違い

- **Direct connection**: ベースライン（最も速い）
- **Transaction pooler**: +1-5ms程度のオーバーヘッド
- **Session pooler**: +1-5ms程度のオーバーヘッド

**理由**:
- Connection Poolingは接続を管理するためのレイヤーが追加される
- しかし、接続の確立コストが削減されるため、実際の差は小さい

### 実際の影響

**小規模なアプリケーション（接続数が少ない場合）**:
- 差はほとんど感じられない（1-5ms程度）
- ユーザー体験への影響はほぼなし

**大規模なアプリケーション（接続数が多い場合）**:
- Transaction poolerの方が有利（接続プーリングにより効率的）
- 接続の確立コストが削減される

---

## 🎯 推奨設定

### Render環境の場合

**推奨**: **Transaction pooler (SHARED POOLER)**

**理由**:
1. ✅ **IPv4互換** - Render環境はIPv4ネットワークのため必須
2. ✅ **スケーラビリティ** - 接続プーリングにより高負荷時にも安定
3. ✅ **パフォーマンス** - レスポンス時間の差は実質的に無視できる（1-5ms）
4. ✅ **コスト効率** - 接続数を効率的に管理

### パフォーマンスへの影響

**レスポンス時間**:
- Direct connection: ベースライン
- Transaction pooler: +1-5ms程度（実質的に無視できる）

**実際のアプリケーションでの影響**:
- APIレスポンス時間: ほとんど差なし（1-5msは全体のレスポンス時間の1%未満）
- データベースクエリ時間: 差なし（クエリ実行時間の方がはるかに長い）
- ユーザー体験: 影響なし

---

## 📈 ベンチマーク例

### 典型的なAPIレスポンス時間

| 処理 | Direct connection | Transaction pooler | 差 |
|------|------------------|-------------------|-----|
| **接続確立** | 10-20ms | 1-2ms（プールから取得） | -8-18ms（有利） |
| **クエリ実行** | 50-200ms | 50-200ms | 差なし |
| **合計** | 60-220ms | 51-202ms | -1-5ms（実質的に同じ） |

**注意**: 接続確立は初回のみ。Transaction poolerは接続を再利用するため、2回目以降は接続確立時間が短縮されます。

---

## 🔍 詳細な比較

### Direct connection

**メリット**:
- ✅ レスポンス時間が最短（直接接続）
- ✅ オーバーヘッドが少ない

**デメリット**:
- ❌ IPv4非互換（Render環境では使用不可）
- ❌ 同時接続数に制限がある
- ❌ 接続の確立コストが高い

**用途**:
- 永続接続が必要なアプリケーション
- 仮想マシンやコンテナで実行されるアプリケーション

---

### Transaction pooler (SHARED POOLER)

**メリット**:
- ✅ IPv4互換（Render環境で使用可能）
- ✅ スケーラビリティが高い（接続プーリング）
- ✅ 接続の確立コストが低い（プールから再利用）
- ✅ ステートレスアプリケーションに最適

**デメリット**:
- ⚠️ わずかなオーバーヘッド（1-5ms程度）

**用途**:
- ステートレスアプリケーション（サーバーレス関数など）
- Webサービス（Render環境など）
- 各トランザクションが短いアプリケーション

---

### Session pooler (SHARED POOLER)

**メリット**:
- ✅ IPv4互換（Render環境で使用可能）
- ✅ Direct connectionの代替として使用可能
- ✅ セッションレベルの接続管理

**デメリット**:
- ⚠️ わずかなオーバーヘッド（1-5ms程度）

**用途**:
- Direct connectionの代替（IPv4ネットワーク経由で接続する場合）

---

## 💡 実用的な推奨事項

### Render環境の場合

**推奨**: **Transaction pooler (SHARED POOLER)**

**理由**:
1. **IPv4互換が必須** - Render環境はIPv4ネットワークのため
2. **パフォーマンス差は無視できる** - 1-5msの差は実質的に影響なし
3. **スケーラビリティ** - 高負荷時にも安定
4. **コスト効率** - 接続数を効率的に管理

### パフォーマンス最適化の優先順位

1. **データベースクエリの最適化** - インデックスの追加、クエリの最適化
2. **アプリケーションロジックの最適化** - 不要な処理の削減
3. **接続方式の選択** - パフォーマンスへの影響は最小（1-5ms）

**結論**: 接続方式によるパフォーマンス差は実質的に無視できるため、IPv4互換性を優先してTransaction poolerを使用することを推奨します。

---

## 📋 まとめ

### レスポンス時間の違い

- **Direct connection**: ベースライン（最も速い）
- **Transaction pooler**: +1-5ms程度（実質的に無視できる）
- **Session pooler**: +1-5ms程度（実質的に無視できる）

### 実用的な推奨

**Render環境**: Transaction pooler (SHARED POOLER) を使用

**理由**:
- ✅ IPv4互換（必須）
- ✅ パフォーマンス差は実質的に無視できる
- ✅ スケーラビリティが高い
- ✅ 接続管理が効率的

---

## 🔗 関連ドキュメント

- [SELECT_SHARED_POOLER.md](./SELECT_SHARED_POOLER.md) - Shared Poolerの選択方法
- [USE_SHARED_POOLER.md](./USE_SHARED_POOLER.md) - Shared Poolerの使用方法
- [FIX_IPV6_CONNECTION_ERROR.md](./FIX_IPV6_CONNECTION_ERROR.md) - IPv6接続エラーの修正

